---
title: 'MetaMask: Context und React'
date: '2023-12-09'
lastmod: '2023-12-09'
tags: ['Web3']
draft: true
summary: 'Wie man MetaMask in einer REACT-Anwendung verwendet'
images: []
authors: ['default']
---

Beim letzten Mal ging es darum, wie man MetaMask in eine Webseite integriert,
genauer gesagt, wie man die Referenz `window.ethereum` benutzt.

Jetzt gehen wir einen Schritt weiter und beschäftigen uns mit der Frage,
wie wir Ethers/MetaMask auf einer komplexen React-Website tatsächlich nutzen können.

Üblicherweise übergibt man sie als `props` an einzelne React-Komponenten. Da diese
ziemlich tief geschachtelt sein können, wird das schnell kompliziert. Man nennt das Problem
**prop drilling**.[^1]

Hier kommt der
[React-Context](https://react.dev/learn/passing-data-deeply-with-context)
ins Spiel. Er verhindert das **prop drilling** und ermöglicht dadurch, dass
ab einem bestimmten Knotenpunkt **alle** Unterkomponenten direkt auf Kontext-Informationen
zugreifen können.

Ich habe den Kontext für diesen Anwendungsfall folgendermassen definiert:

```tsx

const Context = createContext<EthersContextType>({
  ethersProvider: {
    web3Provider: null,
    web3ProviderSetter: null,
    lastBlock: null,
    lastBlockSetter: null,
    defaultMainNetProvider: ethers.getDefaultProvider('mainnet'),
  },
})

```

Weil hier Typescript verwendet wird  (`<EthersContextType>`), ist es möglich, den Kontext
später schnell zu erweitern und dabei von der **Typsicherheit** von Typescript zu profitieren.

Wo der Ethereum-Kontext benötigt wird, kann er nun schnell eingebunden werden, wie z.B. in dieser
Komponente:
```tsx
'use client'

import React, { useEffect, useState, useContext } from 'react'
import Context from '../../app/context/Context'
import { ethers } from 'ethers'

const CurrentNetwork: React.FC = () => {
  const context = useContext(Context)
  const [network, setNetwork] = useState<ethers.Network | null | undefined>(null)
  useEffect(() => {
    context?.ethersProvider?.web3Provider?.getNetwork().then((n) => setNetwork(n))
  }, [context?.ethersProvider?.web3Provider])
  return network ? <span>{network?.name}</span> : <span>`--`</span>
}

export default CurrentNetwork
```

Das ist ein dicht gepacktes Stück Code, aber es profitiert von der Kompaktheit, die
mit **TypeScript** möglich ist. Wenn die **Kontext-API** nicht verwendet würde,
dann würde das an dieser Stelle noch viel wilder und komplizierter aussehen. Mit
ein wenig Grundwissen über React bleibt der Code lesbar.

Wer mehr darüber erfahren möchte, der kann gerne
[hier](https://github.com/lyrx/tailwind/blob/main/app/context/ContextProvider.tsx)
nachschauen.

Es bleibt eigentlich nur zu bemerken, dass alles möglich ist, wenn man
Ethereum und React verheiraten will. Man muss nur wissen, wie es geht ...

[^1]: Wie immer in der Software-Entwicklung birgt jede Erweiterung die Gefahr in sich,
dass die Anwendung zusehends komplizierter wird. **Prop drilling** ist eines
von vielen Beispiel dafür.
Was also tun? -- Der
[React-Context](https://react.dev/learn/passing-data-deeply-with-context) ist ein
möglicher Lösungsansatz dafür. Für React gibt es auch noch viele weitere Context-APIs,
die allerdings als externe Komponenten eingebunden werden müssen. Der React-Context
hat den Vorteil, dass er schon mit dazu gehört.



